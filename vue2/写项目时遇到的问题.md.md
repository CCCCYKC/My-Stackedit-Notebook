# 写项目时遇到的问题
>[Vue基础知识点总结_小胖梅老师的vue2项目-CSDN博客](https://blog.csdn.net/xm1037782843/article/details/131563157?spm=1001.2014.3001.5501)
### 1. node.js 和 MySQL 版本不兼容
**问题：** 后端数据库一直报错“数据库语句错误”
**步骤：** 重新安装了MySQL，降低了版本号

### 2. 上传的图片名字为中文，导致图片的URL为乱码
**想要的效果：** 图片的URL中没有乱码
**步骤：** 在后端 router.js 文件中添加 `encodeURIComponent` 函数
```js
filename:  function (req, file, cb) {
	// 用encodeURIComponent将中文乱码转换成UTF-8 编码,可以用decodeURIComponent再解码回中文
	cb(null, Date.now() +  "-"  +  encodeURIComponent(file.originalname));
},
```

### 3. 上传图片时，不需要定义公共请求方法，直接单个导出接口地址

### 4. 富文本编译器关于初始化和销毁

### 5. 上传产品数据接口参数传递时，在前端对 params 多加了大括号，变成 {params} ，导致后端读取参数不成功

### 6. 产品列表中，搜索后的分页处理
**想要的效果：**
- 每一页最多有8条记录
- 在搜索前不管是在第几页，搜索后的结果都是从第一页开始展示的
- 当搜索后，上面的搜索框改动了但是没查询，仍然按照之前查询的结果来分页

**步骤：**
 1. 定义三个新变量：
	  - `lastSearchWord` ：搜索请求函数中，若 `this.lastSearchWord  !==  search`，则让 `this.lastSearchWord  =  search`
	  - `searchWord` ：点击submit按钮保存的搜索关键词
	  - `isSearch` ：是否处于搜索状态
2. 在点击查询的 `onSubmit` 函数中设置 `this.searchWord  =  this.formInline.name;`，
3. 对分页组件的点击换页函数 `pageChanged` ，判断是否在搜索状态 `isSearch`。
	- 如果是，则根据上次submit的searchWord来重新执行搜索 `this.search(this.searchWord)`
	- 如果不是，则调用获取产品列表数据的方法 `this.projectList(page)`
4. 在搜索接口请求函数 `async  search(search)` ：
	- 当 `search` 为空时，让 `this.isSearch  =  false;`，并直接返回
	- 当 `this.lastSearchWord  !==  search || search 不为空` 时，强制重置当前页为1，并更新 `lastSearchWord` 
	```js
	if (!search) {
		// 搜索关键词为空时，直接不搜索，搜索状态为false,返回
		this.isSearch  =  false;
		return;
	} else  if (this.lastSearchWord  !==  search) {
		// 当搜索值与上次搜索值不同时，强制重置当前页为1，并更新		lastSearchWord
		this.currentPage  =  1;
		this.lastSearchWord  =  search;
	}
	```
	- 设置搜索状态 `this.isSearch  =  true`
	- 当请求成功后，让 `this.total  =  res.data.result.length`，并根据 `currentPage` 来判断应该显示第几条到第几条的记录
```js
this.isSearch  =  true;	// 处于搜索状态
let  res  =  await  this.$api.search({ search });
console.log("搜索数据----", res.data);
if (res.data.status  ===  200) {
	// 处理结果的分页
	this.total  =  res.data.result.length;
	// 第一页显示1-8条记录，第二页显示9-16条记录....
	const  startIndex  = (this.currentPage  -  1) * this.pageSize;
	const  endIndex  =  startIndex  +  this.pageSize;
	// 有结果，只展示当前页的数据
	this.tableData  =  res.data.result.slice(startIndex, endIndex);
} else {
	//无结果
	this.tableData  = [];
	this.total  =  0;
	this.currentPage  =  1;
}
```
### 7. 在编辑产品内容时，怎么保证点击重置按钮后返回的是上次保存的信息
>es6 中的解构语法，涉及浅拷贝和深拷贝，直接赋值（=）和对象展开语法（`{...对象名}`）的区别
>[ES6对象展开语法 - Kimi](https://www.kimi.com/chat/d248gnvahd89tou4ifo0)

1. 使用直接赋值，可以解决
- 若直接赋值 `this.ruleForm = this.rowData`; 会导致 `ruleForm` 和 `rowData` 指向同一内存地址，修改ruleForm会影响rowData

2. 使用解构语法，可以解决“修改 `ruleForm` 会影响 `rowData` ”的问题，但是..
3. 使用深拷贝，`this.ruleForm =JSON.parse(JSON.stringify(this.rowData))`

### 8. 调用接口定义函数方法时，参数是直接使用 `page,total` 还是使用 `params`，会导致调用函数时传的实参格式不同
>[接口调用参数传递方式对比 - Kimi](https://www.kimi.com/chat/d25hqdtf4397pfgb4kd0)
- 使用 `params`，调用函数时就一定要用对象括号包裹，并且写出参数在后端的名称 `this.changeStatus({ids: idStr})`

### 9. 在 `order/list/drawer.vue` 文件中，对浏览器的窗口大小进行监听，同时实时改变 `drawer` 组件的大小

### 10. 面包屑导航---对导航数据的获取 & 对导航的重定向
```js
this.$route.matched

// 异步组件加载
const  Produce  = () =>  import("@/views/produce/index.vue");
const  ProduceList  = () =>  import("@/views/produce/list/index.vue");
{
	path:  "/produce", // 产品管理
	name:  "produce",
	redirect:"/produce/list", //重定向(由于二级菜单为空，让面包屑导航可以跳转)
	component:  Produce,
	meta: {
	title:  '产品管理'
	},
}
```

### 11. `vue-pdf` 库与 `node` 不兼容（直接卸载换另一个）

### 12. `post` 和 `get` 网络请求的传参方式不同（文件：src/api/index.js），在具体使用时的实参传递方式也不同
- `get`：参数要用大括号括起来
```js
//网络请求
projectList(params) {
	return  axios.get(base.projectList, { params })
},
//函数方法
this.changeStatus({ ids:  idStr });
```
- `post`：参数直接传递
```js
//网络请求
login(params) {
	return  axios.post(base.login, params)
},
//函数方法
this.login(this.input.username, this.input.password);
```

### 13. 登录接口使用的是 `post` 方法，传入的参数格式正确，但是后端打印 `res.body` 却为 `undefined`
- 原因：`src/api/index.js` 中并没有导入写好封装好的文件 `src/views/utils/request.js`
- 更正后：
```js
//文件src/api/index.js中
import  instance  from  '@/views/utils/request';

// 登录接口 post params = { user, pwd }
login(params) {
	return  instance.post(base.login, params)
},
```
### 14.拆分路由时，在动态获取路由时，动态匹配到的路由的组件并没有成功加载，导致 produce、order、manage 等组件在 layout 的路由出口无法显示
**原因：深拷贝方法使用不当**
-  `JSON.stringify` 无法处理函数类型（异步组件加载函数 `() => import(...)` 属于函数），会直接忽略函数属性，导致拷贝后的路由对象丢失 `component` 字段

**解决方法：** 将 `JSON.parse(JSON.stringify())` 改为 `loadsh.cloneDeep`

-   `JSON.stringify`  只能处理 JSON 支持的数据类型（字符串、数字、布尔等），会忽略函数、Symbol 等特殊类型，导致异步组件的  `component`  函数丢失。
-   `lodash.cloneDeep`  是专门的深拷贝工具，能正确处理函数、正则等复杂类型，确保路由对象中的  `component`  字段被完整保留。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTMzNjE1NDQ1N119
-->