# 静态方法
>在 JavaScript 中，静态方法是指直接通过构造函数调用的方法，而不是通过构造函数的实例调用的方法。

 ### 静态方法的特点
-   **直接通过构造函数调用**：不需要创建对象的实例，直接通过 `Object` 构造函数调用。

-   **不属于对象的实例**：静态方法不会被对象的实例继承，而是属于构造函数本身
## 1.`Object` 的静态方法
### （1）`Object.defineProperty;`
**添加或修改属性，并设置属性的可读可写等属性**
语法：`Object.defineProperty(obj, prop, descriptor);`
```js
const obj = {};
// 定义一个不可修改的属性
Object.defineProperty(obj, 'a', {
  value: 1,
  writable: false, // 不可修改
  enumerable: true, // 可枚举
  configurable: false // 不可配置
});
console.log(obj.a); // 输出 1
obj.a = 2; // 无效操作，因为 writable 为 false
console.log(obj.a); // 输出 1
```
### （2）`Object.defineProperties`
定义或修改对象的多个属性。
语法：`Object.defineProperties(obj, props)`
```js
const obj = {};
Object.defineProperties(obj, {
  a: {
    value: 1,
    writable: false
  },
  b: {
    value: 2,
    writable: true
  }
});
console.log(obj.a); // 输出 1
console.log(obj.b); // 输出 2
```
### （3）`Object.keys`
获取对象的所有自身可枚举属性名称
### （4）`Object.values`
获取对象的所有自身可枚举属性值
### （5）`Object.entries`
获取对象的所有自身可枚举属性键值对
```js
// 3 4 5
const obj = { a: 1, b: 2 };
Object.defineProperty(obj, 'c', {
  value: 3,
  enumerable: false
});
console.log(Object.keys(obj)); // 输出 ["a", "b"]
console.log(Object.values(obj)); // 输出 [1, 2]
console.log(Object.entries(obj)); // 输出 [["a", 1], ["b", 2]]

```
### （6）`Object.seal`
密封一个对象，使其不能添加新的属性或删除现有属性，但可以修改现有属性的值
```js
const obj = { a: 1, b: 2 };
Object.seal(obj);
obj.a = 3; // 有效操作
console.log(obj.a); // 输出 3
obj.c = 4; // 无效操作
console.log(obj.c); // 输出 undefined
```
### （7）`Object.freeze`
冻结一个对象，使其不可被修改
```js
const obj = { a: 1, b: 2 };
Object.freeze(obj);
obj.a = 3; // 无效操作
console.log(obj.a); // 输出 1
```
### （8）`Object.assign`
将所有可枚举属性的值从一个或多个源对象复制到目标对象
语法：`Object.assign(target, ...sources)`
```js
const target = { a: 1 };
const source = { b: 2, c: 3 };
const result = Object.assign(target, source);
console.log(result); // 输出 { a: 1, b: 2, c: 3 }
```
### （9）`Object.create`
创建一个新对象，使用现有的对象来提供新创建的对象的原型
语法：`Object.create(proto, [propertiesObject])`
```js
const proto = { x: 1 };
const obj = Object.create(proto);
console.log(obj.x); // 输出 1
```

### （10）`Object.hasOwnProperty`：这个是实例方法
`hasOwnProperty` 方法用于检查对象是否拥有指定的属性，并且该属性是对象自身的属性，而不是从原型链上继承来的属性
语法：`object.hasOwnProperty(prop)`
```js
const obj = {
    name: "Alice",
    age: 25
};
console.log(obj.hasOwnProperty("name")); // true
console.log(obj.hasOwnProperty("age"));  // true
console.log(obj.hasOwnProperty("toString")); // false
```


##  2. `Function` 的静态方法

### （1）`Function.prototype.apply`
调用一个函数，并将一个数组（或其他类数组对象）作为参数传递给该函数
语法：`func.apply(thisArg, [argsArray])`
### （2）`Function.prototype.call`
调用一个函数，并将一个对象作为 `this` 值传递给该函数
语法：`func.call(thisArg, arg1, arg2, ...)`
### （3）`Function.prototype.bind`
创建一个新的函数，该函数的 `this` 值被绑定到指定的对象，并且可以预设部分参数。
语法：`func.bind(thisArg, arg1, arg2, ...)`
### （4）`Function.length`
返回函数的形参数量
语法：`func.length`
```js
function sum(a, b) {
  return a + b;
}
console.log(sum.length); // 输出 2
```
### （5）`Function.name`
返回参数的名字
语法：`func.name`
```js
function sum(a, b) {
  return a + b;
}
console.log(sum.name); // 输出 sum
```
### （6）`Function.toString`
返回函数的字符串表示形式，通常是函数的源代码
语法：`func.toString`
```js
function sum(a, b) {
  return a + b;
}
console.log(sum.toString());
// 输出 "function sum(a, b) { return a + b; }"
```
### （7）`Function.prototype`
指向函数的原型对象，所有通过该函数创建的实例都会继承这个原型对象
语法：`func.prototype`
```js
function Person(name) {
  this.name = name;
}
Person.prototype.greet = function() {
  return `Hello, my name is ${this.name}.`;
};
const person = new Person('Alice');
console.log(person.greet()); // 输出 "Hello, my name is Alice."
```
### （8）`Function.arguments`
返回调用当前函数时传递的参数数组，是一个类数组，要使用 `Array.from(arguments)` 转换成真正的数组
语法：`func.arguments`
```js
function sum() {
  console.log(arguments);
}
sum(1, 2, 3);
// 输出 Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]
```

## 3.`Array` 的静态方法
### （1）`Array.from()`
`Array.from()` 是一个 ES6 方法，用于将类数组对象（如 `arguments`）转换为真正的数组。这样可以方便地使用数组方法
用法：`Array.from(arguments)`

### （2）`Array.isArray`

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTUyMzU4Nzk2M119
-->