# 闭包函数
**闭包是一个函数，它能够记住并访问其创建时所在的作用域链中的变量，即使该函数在其创建上下文之外执行。**
### 闭包可能形成的问题：
- ### **内存泄漏**
闭包会持有**外部变量的引用**，如果这些变量占用大量内存，而**闭包又没有被正确释放**，可能会导致**内存泄漏**

### 关键点

1.  **函数返回函数**：闭包通常是一个函数返回另一个函数。
    
2.  **捕获变量**：返回的函数能够访问其创建时所在的作用域中的变量，这些变量在父级函数执行结束后仍然可以被访问。
    
3.  **延迟执行**：返回的函数可以在任何时间被调用，但它仍然可以访问创建时捕获的变量。
4. **典型例子**：`function.bind()`
    
### 通俗解释

假设你有一个盒子（函数），这个盒子里有一些工具（变量）。当你把这个盒子从一个房间（作用域）带到另一个房间（不同的作用域）时，你仍然可以使用盒子里的工具。这个盒子就是闭包

### 我的理解
就是函数的返回值也为函数，并且**返回值的函数能够访问父级函数的参数以及局部变量**——这些变量在父级函数执行结束后仍然可以被访问，因为它们被闭包“捕获”了

父级函数可以传递参数，通常是将父级参数赋予给一个变量，然后再给变量赋参数从而调用闭包

例子：
```js
function outerFunction(outerParam) {
    let outerVariable = "I am from outer function"; // 局部变量
    function innerFunction(innerParam) {
        console.log(outerParam); // 访问父级函数的参数
        console.log(outerVariable); // 访问父级函数的局部变量
        console.log(innerParam); // 访问内部函数的参数
    }
    return innerFunction; // 返回内部函数
}
// 调用
const myClosure = outerFunction("Hello"); // myClosure 是一个闭包
myClosure("World"); // 输出: Hello, I am from outer function, World
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjA0Mjg1NDgyNSwtOTk0NjkwOTI2XX0=
-->