# Vue3基本知识
>从初学者我的角度来看，vue3 与 vue2 最大的区别就是 JavaScript 的写法，vue3 可以直接使用语法糖 `<script setup></script>`，可以将定义的变量、方法函数分开来写，不用放在一起再导出
>各种属性computed、watchs等都会以函数的形式来展现

## 1. 创建变量 `ref/reactive`
### （1）`ref`
- `ref()` 接收参数，并将其包裹在一个带有 `.value` 属性的 ref 对象中返回：
```js
const count = ref(0)

console.log(count) // { value: 0 }
console.log(count.value) // 0

count.value++
console.log(count.value) // 1
```
- 要对 `ref` 的值进行改变，必须通过 `.value` 来访问（`reactive` 则不用）
- `ref` 在 `<template></template>` 中用大括号使用时，会自动解包，但在JavaScript中使用时，就需要使用 `变量名.value` 来对值进行改变
```html
<script setup>  
import { ref } from 'vue'  
const count = ref(0)  
function increment() {  
	count.value++  
}  
</script>
<template>
	<h2 @click="increment()">Count: {{ count }}</h2>
</template>
```
### （2）`reactive`
- `reactive` 只能接收对象为参数
- 使用 `reactive` 来定义一个对象，可以直接访问和修改它的属性，而不需要 `.value`
```js
const raw = {}
const proxy = reactive(raw)
// 代理对象和原始对象不是全等的
console.log(proxy === raw) // false
```
```html
<script setup>
import { reactive } from 'vue'
const state = reactive({ count: 0 })
</script>
<button @click="state.count++">{{ state.count }}</button>
```

## 2. 计算属性 `computed`
>默认只是可读的，要变成可写的要通过同时提供 getter 和 setter 来创建
- `computed()` 方法期望接收一个 getter 函数，返回值为一个**计算属性 ref**。和其他一般的 ref 类似，你可以通过 `publishedBooksMessage.value` 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 `.value`。
- Vue 的计算属性会自动追踪响应式依赖。它会检测到 `publishedBooksMessage` 依赖于 `author.books`，所以**当 `author.books` 改变时，任何依赖于 `publishedBooksMessage` 的绑定都会同时更新**
- 一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 `author.books` 不改变，无论多少次访问 `publishedBooksMessage` 都会立即返回先前的计算结果，而**不用重复执行 getter 函数**。
```html
<script setup>
import { reactive, computed } from 'vue'
const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide',
    'Vue 4 - The Mystery'
  ]
})
// 一个计算属性 ref
const publishedBooksMessage = computed(() => {
  return author.books.length > 0 ? 'Yes' : 'No'
})
</script>

<template>
  <p>Has published books:</p>
  <span>{{ publishedBooksMessage }}</span>
</template>
```
- 计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建：
```html
<script setup>
import { ref, computed } from 'vue'

const firstName = ref('John')
const lastName = ref('Doe')

const fullName = computed({
  // getter
  get() {
    return firstName.value + ' ' + lastName.value
  },
  // setter
  set(newValue) {
    // 注意：我们这里使用的是解构赋值语法
    [firstName.value, lastName.value] = newValue.split(' ')
  }
})
</script>
```
**如果调用 `fullName = 'marry a'`，则会更新 `firstName` 和 `lastName`**
- 传递参数 `previous` 来获取上一个满足条件的值
```html
<script setup>
import { ref, computed } from 'vue'
const count = ref(2)

// 这个计算属性在 count 的值小于或等于 3 时，将返回 count 的值。
// 当 count 的值大于等于 4 时，将会返回满足我们条件的最后一个值
// 直到 count 的值再次小于或等于 3 为止。
const alwaysSmall = computed((previous) => {
  if (count.value <= 3) {
    return count.value
  }
  return previous
})
</script>
```
## 3. Class 与 Style 绑定（class也可以使用v-bind）


## 补充
### 1. `nextTick()`
- `nextTick()` 的作用是告诉 Vue：“等 DOM 更新完成后，再执行某个操作。”它确保你的操作是在 DOM 更新之后进行的。
- Vue2 中使用要用 `this.$nextTick`，在 Vue 3 中，`nextTick()` 是一个全局方法，可以直接从 Vue 的 API 中导入使用
```html
<template>
  <div>
    <p id="message">{{ message }}</p>
    <button @click="updateMessage">Update Message</button>
  </div>
</template>

<script setup>
import { ref, nextTick } from 'vue';
// 定义一个响应式变量
const message = ref('Hello, Vue 3!');
// 定义一个方法来更新消息
async function updateMessage() {
	// 更新数据
	message.value = 'Updated Message';
	// 使用 nextTick 确保 DOM 更新完成后执行操作
	await nextTick();
	console.log(document.querySelector('#message').textContent); // 输出 "Updated Message"
}
</script>
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTc0NDc4NjY1MV19
-->