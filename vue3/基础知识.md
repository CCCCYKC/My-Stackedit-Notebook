# Vue3 基础知识
>从初学者我的角度来看，vue3 与 vue2 最大的区别就是 JavaScript 的写法，vue3 可以直接使用语法糖 `<script setup></script>`，可以将定义的变量、方法函数分开来写，不用放在一起再导出
>各种属性computed、watchs等都会以函数的形式来展现

## 1. 创建变量 `ref/reactive`
>一般简单变量用 `ref`，复杂变量用 `reactive`
### （1）`ref`
- `ref()` 接收参数，并将其包裹在一个带有 `.value` 属性的 ref 对象中返回：
```js
const count = ref(0)

console.log(count) // { value: 0 }
console.log(count.value) // 0

count.value++
console.log(count.value) // 1
```
- 要对 `ref` 的值进行改变，必须通过 `.value` 来访问（`reactive` 则不用）
- `ref` 在 `<template></template>` 中用大括号使用时，会自动解包，但在JavaScript中使用时，就需要使用 `变量名.value` 来对值进行改变
```html
<script setup>  
import { ref } from 'vue'  
const count = ref(0)  
function increment() {  
	count.value++  
}  
</script>
<template>
	<h2 @click="increment()">Count: {{ count }}</h2>
</template>
```
### （2）`reactive`
- `reactive` 只能接收对象、数组为参数
- 使用 `reactive` 来定义一个对象，可以直接访问和修改它的属性，而不需要 `.value`
```js
const raw = {}
const proxy = reactive(raw)
// 代理对象和原始对象不是全等的
console.log(proxy === raw) // false
```
```html
<script setup>
import { reactive } from 'vue'
const state = reactive({ count: 0 })
</script>
<button @click="state.count++">{{ state.count }}</button>
```

## 2. 计算属性 `computed`
>默认只是可读的，要变成可写的要通过同时提供 getter 和 setter 来创建
- `computed()` 方法期望接收一个 getter 函数，返回值为一个**计算属性 ref**。和其他一般的 ref 类似，你可以通过 `publishedBooksMessage.value` 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 `.value`。
- Vue 的计算属性会自动追踪响应式依赖。它会检测到 `publishedBooksMessage` 依赖于 `author.books`，所以**当 `author.books` 改变时，任何依赖于 `publishedBooksMessage` 的绑定都会同时更新**
- 一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 `author.books` 不改变，无论多少次访问 `publishedBooksMessage` 都会立即返回先前的计算结果，而**不用重复执行 getter 函数**。
```html
<script setup>
import { reactive, computed } from 'vue'
const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide',
    'Vue 4 - The Mystery'
  ]
})
// 一个计算属性 ref
const publishedBooksMessage = computed(() => {
  return author.books.length > 0 ? 'Yes' : 'No'
})
</script>

<template>
  <p>Has published books:</p>
  <span>{{ publishedBooksMessage }}</span>
</template>
```
- 计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建：
```html
<script setup>
import { ref, computed } from 'vue'

const firstName = ref('John')
const lastName = ref('Doe')

const fullName = computed({
  // getter
  get() {
    return firstName.value + ' ' + lastName.value
  },
  // setter
  set(newValue) {
    // 注意：我们这里使用的是解构赋值语法
    [firstName.value, lastName.value] = newValue.split(' ')
  }
})
</script>
```
**如果调用 `fullName = 'marry a'`，则会更新 `firstName` 和 `lastName`**
- 传递参数 `previous` 来获取上一个满足条件的值
```html
<script setup>
import { ref, computed } from 'vue'
const count = ref(2)

// 这个计算属性在 count 的值小于或等于 3 时，将返回 count 的值。
// 当 count 的值大于等于 4 时，将会返回满足我们条件的最后一个值
// 直到 count 的值再次小于或等于 3 为止。
const alwaysSmall = computed((previous) => {
  if (count.value <= 3) {
    return count.value
  }
  return previous
})
</script>
```
## 3. Class 与行内 Style 绑定
>即 `class` 属性使用 `v-bind` 绑定来控制是否渲染
### （1）绑定 HTML Class
- 当 `isActive` 或者 `hasError` 改变时，class 列表会随之更新
```html
<script>
import { ref } from 'vue'
const isActive = ref(true)
const hasError = ref(false)
</script>
<div
  class="static"
  :class="{ active: isActive, 'text-danger': hasError }"
></div>
```
- 绑定的对象并不一定需要写成内联字面量的形式，也可以直接绑定一个对象：
```html
<script>
const classObject = reactive({
  active: true,
  'text-danger': false
})
</script>
<div :class="classObject"></div>
```
- 我们也可以绑定一个返回对象的计算属性 `computed`。这是一个常见且很有用的技巧：
```html
<script>
const isActive = ref(true)
const error = ref(null)
const classObject = computed(() => ({
  active: isActive.value && !error.value,
  'text-danger': error.value && error.value.type === 'fatal'
}))
</script>
<div :class="classObject"></div>
```
- 也可以绑定数组
```html
<script>
const activeClass = ref('active')
const errorClass = ref('text-danger')
</script>
<div :class="[activeClass, errorClass]"></div>
```
- 对于只有一个根元素的组件，当你使用了 `class` attribute 时，这些 class 会被添加到根元素上并与该元素上已有的 class 合并。
```html
//子组件中
<p class="foo bar">Hi!</p>
//父组件中
<MyComponent class="baz boo" />
//使用组件时的class属性会合并在组件的根元素上
```
### （2）绑定行内 Style
>行内 style 中，所有带 `-` 的属性都被改写成驼峰式的写法 
- `:style` 支持绑定 JavaScript 对象值
```html
<script>
const activeColor = ref('red')
const fontSize = ref(30)
</script>
<div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
```


## 4. 条件渲染
> `v-if` `v-else` `v-else-if` `v-show`
> 
### `v-if` 与 `v-show` 的区别：
1.  `v-if = false` 时，就不会渲染，直接将组件销毁
2.  `v-show` 时，就相当于 `display: none`。组件始终会被渲染，只有 CSS `display` 属性会被切换。
3. 如果需要频繁切换，则使用 `v-show` 较好；如果在运行时绑定条件很少改变，则 `v-if` 会更合适

## 5. 列表渲染 `v-for`
- `v-for` 常跟 `:key` 连用
- `v-for` 的遍历对象可以为数组或对象，遍历参数最多有3：`(item, key, index)`
```html
<li v-for="(value, key, index) in myObject">
  {{ index }}. {{ key }}: {{ value }}  
</li>
```
- **展示过滤或排序后的结果：**
	- 常常与数组方法 `filter` 连用
```html
<script>
const sets = ref([[1, 2, 3, 4, 5],[6, 7, 8, 9, 10]])
function even(numbers) {
  return numbers.filter((number) => number % 2 === 0)
}
</script>
<ul v-for="numbers in sets">
  <li v-for="n in even(numbers)">{{ n }}</li>
</ul>
```

## 6. 事件处理 `v-on`
>我们可以使用 `v-on` 指令 (简写为 `@`) 来监听 DOM 事件，并在事件触发时执行对应的 JavaScript。
>用法：`v-on:click="handler"` 或 `@click="handler"`
>- [事件修饰符等操作 | Vue.js](https://cn.vuejs.org/guide/essentials/event-handling.html#event-modifiers)

## 7. 表单输入绑定 `v-model`
> `v-model` = `v-bind` + `v-on`
- 不仅文本框，radio、checkbox、textarea、button、select等都可以绑定，但是要设定 `value` 值，以便加入到绑定的变量当中
```html
<script>
const checkedNames = ref([])
</script>
<div>Checked names: {{ checkedNames }}</div>

<input type="checkbox" id="jack" value="Jack" v-model="checkedNames" />
<label for="jack">Jack</label>
<input type="checkbox" id="john" value="John" v-model="checkedNames" />
<label for="john">John</label>
<input type="checkbox" id="mike" value="Mike" v-model="checkedNames" />
<label for="mike">Mike</label>
```
- [表单输入绑定的修饰符 | Vue.js](https://cn.vuejs.org/guide/essentials/forms.html#modifiers)
	- `.trim`：默认自动去除用户输入内容中两端的空格 `<input v-model.trim="msg" />`

## 8. 侦听器 `watch` 和 `watchEffect`
**侦听器必须侦听响应式数据源 `ref` 或 `reactive`**
### （1）`watch`
- `watch` 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组
- 但参数不能直接是响应式对象的属性值，例如：`obj.count`
```js
const x = ref(0)
const y = ref(0)
// 单个 ref
watch(x, (newX) => { console.log(`x is ${newX}`)} )
// getter 函数
watch(
  () => x.value + y.value,
  (sum) => {
    console.log(`sum of x + y is: ${sum}`)
  }
)
// 多个来源组成的数组
watch([x, () => y.value], ([newX, newY]) => {
  console.log(`x is ${newX} and y is ${newY}`)
})
```
### （2）`watchEffect`
- `watchEffect()` 可以自动跟踪回调的响应式依赖，即比起 `watch` 可以不用写第一个参数，`watchEffect()` 能之间监听副作用中出现的所有变量
- 对于有**多个依赖项的侦听器**来说，使用 `watchEffect()` 可以消除手动维护依赖列表的负担
```js
watchEffect(async () => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}` //监听 todoId.value
  )
  data.value = await response.json()
})
```
### （3）副作用清理
>假设监听器的副作用为异步操作。若正在执行本次异步时，监听的变量又改变了，这时可以使用 [`onWatcherCleanup()`](https://cn.vuejs.org/api/reactivity-core.html#onwatchercleanup)  API 来注册一个清理函数，当侦听器失效并准备重新运行时会被调用
```js
// 示例1
import { watch, onWatcherCleanup } from 'vue'
watch(id, (newId) => {
  const controller = new AbortController()
  fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {
    // 回调逻辑
  })
  onWatcherCleanup(() => {
    // 终止过期请求
    controller.abort()
  })
})
// 示例2
import { watch, onWatcherCleanup } from 'vue'
watch(id, (newId) => {
  const { response, cancel } = doAsyncWork(newId)
  // 如果 `id` 变化，则调用 `cancel`，
  // 如果之前的请求未完成，则取消该请求
  onWatcherCleanup(cancel)
})
```
## 9. 模版引用 `ref`属性
>它允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用
- 常用在组件的实例获取上
```html
<script setup>
import { useTemplateRef, onMounted } from 'vue'
import Child from './Child.vue'
const childRef = useTemplateRef('child')
onMounted(() => {
  // childRef.value 将持有 <Child /> 的实例
  // 可对组件Child 内的变量、方法进行调用
})
</script>

<template>
  <Child ref="child" />
</template>
```
## 10. 组件基础
### （1）父传子：传递 `props` ----- `defineProps` 宏
>与 vue2 不同，vue3 在传递 props 时需要用 `defineProps` 来声明接收到的 `props`
```js
//在子组件中
const props = defineProps(['title'])
console.log(props.title)
```
- 还可以使用列表渲染 `props`
```html
// 父组件中
<script>
const posts = ref([  
	{ id: 1, title: 'My journey with Vue' },  
	{ id: 2, title: 'Blogging with Vue' },  
	{ id: 3, title: 'Why Vue is so fun' } 
])
</script>
<BlogPost
  v-for="post in posts"
  :key="post.id"
  :title="post.title"
 />
// 子组件中
<script>
const props = defineProps(['title', 'id'])
</script>
```
### （2）子传父：`$emit` 方法 
- 子组件的参数是父组件的触发事件的名称
- 使用 `defineEmits` 宏来定义
```html
//子组件先声明
<!-- BlogPost.vue -->
<script setup>
defineProps(['title'])
defineEmits(['enlarge-text'])
</script>
<template>
  <div class="blog-post">
    <h4>{{ title }}</h4>
    <button @click="$emit('enlarge-text')">Enlarge text</button>
  </div>
</template>
//父组件添加函数
<BlogPost
  ...
  @enlarge-text="postFontSize += 0.1"
 />
```

### （3）父传子：插槽 `slot`
>跟 vue2 一样的用法：子组件用 `<slot></slot>` 来占位，父组件在组件标签中间输入要插入的值
- 子组件中在 `<slot></slot>` 内可输入内容，作为父组件没有插槽传入的默认值
```html
// 子组件中
<template>
  <div class="alert-box">
    <strong>This is an Error for Demo Purposes</strong>
    <slot>默认内容</slot>
  </div>
</template>
// 父组件中
<AlertBox>
  Something bad happened.
</AlertBox>
```
- 当想要将多个插槽放在子组件的不同地方时，要用到 `name` 属性和 `v-slot`
```html
//子组件中
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot> //没有提供 `name` 的出口会隐式地命名为“default”
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>

//父组件中
<BaseLayout>
  <template #header>
    <h1>Here might be a page title</h1>
  </template>

  <template #default>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </template>

  <template #footer>
    <p>Here's some contact info</p>
  </template>
</BaseLayout>
```
### （4）动态组件：相互切换 `is` `<KeepAlive>`
- 定义子组件
```html
// 3个组件Home、Posts、Settings的结构都长这样
<template>
  <div>
    <h2>Home</h2>
    <p>Welcome to the Home tab!</p>
  </div>
</template>
<script setup>
</script>
```
- 父组件	
	- `<KeepAlive>`：使用 `<KeepAlive>` 包裹动态组件，可以保持组件的状态，避免切换时组件被销毁和重新创建。
	- 使用 `<component :is="currentTab"></component>` 来动态切换组件。
	- `currentTab` 是一个响应式变量，通过点击按钮来改变它的值，从而切换不同的组件
```html
<template>
  <div>
    <h1>Dynamic Component Example</h1>
    <button v-for="(_, tab) in tabs" :key="tab" :class="['tab-button', { active: currentTab === tab }]" @click="currentTab = tab">
		{{ tab }}
	</button>
    <keep-alive>
      <component :is="tabs[currentTab]"></component>
    </keep-alive>
  </div>
</template>

<script setup>
import { ref } from "vue";
import Home from "./components/Home.vue";
import Posts from "./components/Posts.vue";
import Settings from "./components/Settings.vue";
const currentTab = ref(Home);	//默认打开Home组件
const tabs = { Home, Posts, Archive }
</script>
```

## 11. 生命周期
>[组合式 API：生命周期钩子 | Vue.js](https://cn.vuejs.org/api/composition-api-lifecycle.html)
>生命周期顺序：
>setup--->beforeCreate--->created--->beforeMount--->mounted--->beforeUpdate--->update--->beforeUnmount--->unmounted
>这里介绍常用的3个生命周期钩子：`onMounted` `onUpdate` `onUnmounted`
>**与 vue2 不同，没有 created 的生命周期钩子**

### （1）`onMounted`：在组件挂载完成后执行
```html
<script setup>
import { ref, onMounted } from 'vue'
const el = ref()
onMounted(() => {		//通过模板引用访问一个元素
  el.value // <div>
})
</script>

<template>
  <div ref="el"></div>
</template>
```
### （2）`onUpdate`：在组件因为响应式状态变更而更新其 DOM 树之后调用
- 父组件的更新钩子将在其子组件的更新钩子之后调用
- 如果需要在某个特定的状态更改后访问更新后的 DOM，请使用 [nextTick()](https://cn.vuejs.org/api/general.html#nexttick) 作为替代
```html
<script setup>
import { ref, onUpdated } from 'vue'
const count = ref(0)
onUpdated(() => {
  // 文本内容应该与当前的 `count.value` 一致
  console.log(document.getElementById('count').textContent)
})
</script>

<template>
  <button id="count" @click="count++">{{ count }}</button>
</template>
```
### （3）`onUnmounted`：在组件实例被卸载之后调用
- 可以在这个钩子中手动清理一些副作用，例如计时器、DOM 事件监听器或者与服务器的连接
```html
<script setup>
import { onMounted, onUnmounted } from 'vue'
let intervalId
onMounted(() => {
  intervalId = setInterval(() => {
    // ...
  })
})
onUnmounted(() => clearInterval(intervalId))
</script>
```





## 补充
### 1. `nextTick()` 
- `nextTick()` 的作用是告诉 Vue：“等 DOM 更新完成后，再执行某个操作。”它确保你的操作是在 DOM 更新之后进行的。
- `nextTick()` 可以在状态改变后立即使用，以等待 DOM 更新完成。你可以传递一个回调函数作为参数，或者 await 返回的 Promise
- Vue2 中使用要用 `this.$nextTick`，在 Vue 3 中，`nextTick()` 是一个全局方法，可以直接从 Vue 的 API 中导入使用
- 类似于一个 `setTimeout`，但没有具体时间，而是等 DOM 更新完毕
```html
<template>
  <div>
    <p id="message">{{ message }}</p>
    <button @click="updateMessage">Update Message</button>
  </div>
</template>

<script setup>
import { ref, nextTick } from 'vue';
// 定义一个响应式变量
const message = ref('Hello, Vue 3!');
// 定义一个方法来更新消息
async function updateMessage() {
	// 更新数据
	message.value = 'Updated Message';
	console.log(document.querySelector('#message').textContent); // 输出'Hello, Vue 3!'
	// 使用 nextTick 确保 DOM 更新完成后执行操作
	await nextTick();
	console.log(document.querySelector('#message').textContent); // 输出 "Updated Message"
}
</script>
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTU4NzYwMjMxNV19
-->