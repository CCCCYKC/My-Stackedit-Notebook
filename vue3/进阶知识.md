# VUE3 进阶知识

## 1. `props` 声明
>所有的 props 都遵循着**单向绑定**原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递
>props 是只读的
- 声明方法可以用数组、对象（推荐，有类型检验）
- 声明 `props` 还可以对其设置**默认值、类型检验、是否必填**
```html
<script setup>
const props = defineProps({  // 或 const props = defineProps(['foo'])
	title: String,  
	likes: Number{
		type: String,
		required: true
	},  
	likes: {
		type: [Number, null],
		default: 100
	}  
})
console.log(props.title, props.likes)
</script>
```
- 若要监听传递进来的 `props`，只能将其包装在 `getter` 中来侦听解构的 `prop`
```js
const { foo } = defineProps(['foo'])
watch(() => foo, /* ... */)
```

## 2. 事件 `$emit`
- `$emit` 可传递两个参数，为 `$emit('事件名称', 参数)`，参数会成为父组件触发事件的参数
- 若有多个参数，则用大括号包裹 `$emit('事件名称', { 参数1, 参数2 })`
- 同时，在子组件中要通过 `defineEmits()` 宏来声明它要触发的事件
```html
// 子组件
<script setup>
defineEmits(['increaseBy'])
</script>
<button @click="$emit('increaseBy', 1)">
  Increase by 1
</button>

// 父组件
<script>
function increaseCount(n) {
  count.value += n
}
</script>
<MyButton @increase-by="increaseCount" />
```
- **补充：** 还可以对事件和其参数进行检验
```html
<script setup>
const emit = defineEmits({
  // click 事件没有校验
  click: null,
  // 校验 submit 事件
  submit: ({ email, password }) => {
    if (email && password) {
      return true
    } else {
      console.warn('Invalid submit event payload!')
      return false
    }
  }
})
function submitForm(email, password) {
  emit('submit', { email, password })
}
</script>
```

## 3. `v-model`
- vue3 中，使用 `v-model` 时要先定义 `defineModel` 
- `defineModel` 返回的是一个 `ref`，它可以像其他 ref 一样被访问以及修改，不过它能起到在父组件和当前变量之间的双向绑定的作用
- 还可以设定默认值、是否必填
```html
<script setup>
const model = defineModel()
// 使 v-model 必填
//const model = defineModel({ required: true })
// 提供一个默认值 (父子组件传递中不推荐, 会使得传递的 props 的值不同)
//const model = defineModel({ default: 0 })
</script>

<template>
  <input v-model="model" />
</template>
```

## 4. 访问组件实例的方法和属性
> 由于 VUE3 不像 VUE2 一样有 `this` 上下文可以直接访问，在 Vue 3 的 `setup` 函数中，由于没有 `this` 上下文
- 需要通过 `getCurrentInstance` 获取当前组件实例
- `$nextTick`：这是 Vue 的一个全局 API，用于延迟回调的执行直到下次 DOM 更新循环之后。在 Vue 3 中，这个方法需要通过组件实例的 `proxy` 来访问
```js
import { ref, reactive, getCurrentInstance, nextTick } from  "vue";
const { proxy } = getCurrentInstance();
const instance = getCurrentInstance();
// 直接调用，设置emit事件
instance.emit('tap',传递的变量);		// 触发自定义事件

// 直接访问
console.log(instance.slots); // 访问组件的插槽
console.log(instance.parent); // 访问组件的父组件实例
// 访问组件的属性（props）
console.log(instance.attrs); // 可以但是不推荐
// 推荐
import { defineProps } from 'vue';
const props = defineProps({
	myProp: String
});
console.log(props.myProp); // 访问 props

// $nextTick 需要通过 proxy 访问
instance.proxy.$nextTick(() => {
	console.log('DOM 更新完成');
});
```
- 在大多数情况下，应该优先使用 Vue 3 提供的 Composition API，如 `ref`、`reactive`、`computed`、`watch` 等，来组织和管理组件的状态和逻辑


## 4. 在 vue3 的原型链上添加全局属性
- 给全局属性或方法前加上 `$` 前缀是约定俗成的
- `$` 前缀明确表示这些属性或方法是全局性的，并减少命名冲突
```js
// main.js
import { createApp } from 'vue';
import App from './App.vue';
const app = createApp(App);

// 添加全局属性
app.config.globalProperties.$myGlobalProperty = 'Hello, World!';
// 添加全局方法
app.config.globalProperties.$myGlobalMethod = function() {
  console.log('This is a global method');
};
app.mount('#app');
```
在组件中使用：
```html
<!-- App.vue -->
<template>
  <button @click="$myGlobalMethod">Click me</button>
</template>

<script setup>
const instance = getCurrentInstance();
// 直接访问全局属性
const { $myGlobalProperty, $myGlobalMethod } = instance.appContext.config.globalProperties;
</script>
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTk5MzE1MDY0MywxNzA3Nzc5MjUxXX0=
-->